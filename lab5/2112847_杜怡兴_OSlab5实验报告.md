## 2112847-操作系统-lab5

[TOC]

### 基本理解

#### 进程结构`proc_struct`添加了三个属性

![image-20231203121945874](C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20231203121945874.png)

#### `alloc_proc`

#### `set_proc_name、get_proc_name`

![image-20231203124501380](C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20231203124501380.png)

#### 链表添加进程set_links

![image-20231203121955713](C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20231203121955713.png)

#### 链表删除进程remove_links

![image-20231203122113534](C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20231203122113534.png)

#### `get_pid`

![image-20231203124313065](C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20231203124313065.png)

#### `proc_run`

![image-20231203124807796](C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20231203124807796.png)

#### `forkret、copy_thread`

![image-20231203162418907](C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20231203162418907.png)

#### 退出当前进程并处理父子进程`do_exit`

![image-20231210130314640](C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20231210130314640.png)



**为什么子进程需要设置a0=0:**
`fork()` 调用之后，程序同时在父进程和子进程中继续执行,父进程和子进程都将执行 `if` 语句，但它们将根据 `fork()` 的返回值进入不同的分支。

```cpp
int main() {
    pid_t pid;

    // 调用 fork()
    pid = fork();

    // fork() 返回两次：一次在父进程中，一次在子进程中
    if (pid < 0) {
        // fork 失败
        fprintf(stderr, "Fork failed");
        return 1;
    } else if (pid == 0) {
        // 子进程中，fork 返回 0
        printf("This is the child process. PID = %d\n", getpid());
    } else {
        // 父进程中，fork 返回子进程的 PID
        printf("This is the parent process. PID = %d, child PID = %d\n", getpid(), pid);
    }

    return 0;
}
```

#### 哈希链表的更多操作`hash_proc、unhash_proc、find_proc`

![image-20231203122235008](C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20231203122235008.png)

#### kernel_thread![image-20231210171618591](C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20231210171618591.png)

#### do_fork

![image-20231210172542563](C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20231210172542563.png)

#### 进程创建/释放内核栈`setup_kstack`

![image-20231203165624029](C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20231203165624029.png)

#### `put_kstack`
![image-20231203165634214](C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20231203165634214.png)

#### 内存管理器创建/释放页目录`setup_pgdir,put_pgdir`

![image-20231203122250405](C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20231203122250405.png)

 #### 复制当前进程的内存管理结构到进程proc:`copy_mm`

![image-20231210125905379](C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20231210125905379.png)

#### 退出当前进程`do_exit`

![image-20231203183618127](C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20231203183618127.png)

#### 进程调度`cpu_idle、do_yield、sched.c/schedule`

![image-20231210140702905](C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20231210140702905.png)

#### 唤醒sched.c/wakeup_proc
![image-20231210141432967](C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20231210141432967.png)

#### vmm.c/user_mem_check

![image-20231210143431079](C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20231210143431079.png)

#### do_wait
![image-20231210145231608](C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20231210145231608.png)

#### 杀死进程do_kill会导致doWait进而doExit

![image-20231204000839647](C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20231204000839647.png)

#### proc_init和init_main

![image-20231210155319655](C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20231210155319655.png)

#### user_main->KERNEL_EXECVE2->__KERNEL_EXECVE->do_execve

![image-20231210163443980](C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20231210163443980.png)

#### do_execve
![image-20231210165122966](C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20231210165122966.png)

#### elf.h

##### ELF魔数（Magic Number）

- `#define ELF_MAGIC 0x464C457FU`: 一个用于识别ELF文件的魔数，用小端表示为 `"\x7FELF"`。任何ELF文件的开始都应该有这个魔数。

##### 文件头（File Header）

- struct elfhdr: 这个结构描述了ELF文件的整体布局和属性。
  - **`e_magic`**: 文件的魔数，用于验证文件格式。
  - `e_elf[12]`: ELF标识符，包括类别、数据编码和版本等。
  - `e_type`: 文件类型，如可执行文件、可重定位文件等。
  - `e_machine`: 目标机器架构，如x86、ARM等。
  - `e_version`: 文件版本。
  - **`e_entry`**: 如果文件是可执行的，这是程序的入口点。
  - **`e_phoff`**: 程序头表的文件偏移量。
  - `e_shoff`: 节头表的文件偏移量。
  - `e_flags`: 体系结构特定的标志。
  - `e_ehsize`: ELF头的大小。
  - `e_phentsize`: 程序头表项的大小。
  - `e_phnum`: 程序头表项的数量。
  - `e_shentsize`: 节头表项的大小。
  - `e_shnum`: 节头表项的数量。
  - `e_shstrndx`: 包含节名称字符串的节索引。

#####  程序段头（Program Section Header）

- struct proghdr: 描述文件中各个程序段的信息。
  - `p_type`: 段的类型，如可加载的代码或数据。
  - `p_flags`: 段的权限标志，如读/写/执行。
  - `p_offset`: 段在文件中的偏移量。
  - `p_va`: 段的虚拟地址。
  - `p_pa`: 段的物理地址（通常不使用）。
  - `p_filesz`: 段在文件中的大小。
  - `p_memsz`: 段在内存中的大小。
  - `p_align`: 段的对齐要求。

#####  段类型和标志

- `#define ELF_PT_LOAD 1`: 表示段是可加载的。
- `#define ELF_PF_X 1`: 可执行。
- `#define ELF_PF_W 2`: 可写。
- `#define ELF_PF_R 4`: 可读。

#### load_icode

![image-20231210193030643](C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20231210193030643.png)

![image-20231210193044841](C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20231210193044841.png)

#### vmm.c/dup_mmap

![image-20231210221239989](C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20231210221239989.png)

#### copy_range

![image-20231210223510444](C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20231210223510444.png)

### **8.1.2.1.1.1 练习 0：填写已有实验**

本实验依赖实验 1/2/3/4。请把你做的实验 1/2/3/4 的代码填入本实验中代码中有“LAB1”/“LAB2”/“LAB3”/“LAB4”的注释相应部分。注意：为了能够正确执行 lab5 的测试应用程序，可能需对已完成的实验 1/2/3/4 的代码进行进一步改进。

### **8.1.2.1.1.2 练习 1: 加载应用程序并执行（需要编码）**

**do_execv** 函数调用 `load_icode`（位于 `kern/process/proc.c` 中）来加载并解析一个处于内存中的 ELF 执行文件格式的应用程序。你需要补充 `load_icode` 的第 6 步，建立相应的用户内存空间来放置应用程序的代码段、数据段等，且要设置好 `proc_struct` 结构中的成员变量 `trapframe` 中的内容，确保在执行此进程后，能够从应用程序设定的起始执行地址开始执行。需设置正确的 `trapframe` 内容。

请在实验报告中简要说明你的设计实现过程。

- 请简要描述这个用户态进程被 ucore 选择占用 CPU 执行（RUNNING 态）到具体执行应用程序第一条指令的整个经过。

  **设计实现过程见上图，proc.c/load_icode**

```cpp
    tf->gpr.sp = USTACKTOP;
    tf->epc = elf->e_entry;
    // Set SPP to 0 so that we return to user mode
    // Set SPIE to 1 so that we can handle interrupts
    tf->status = (sstatus & ~SSTATUS_SPP) | SSTATUS_SPIE;
```

![image-20231210225655779](C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20231210225655779.png)。

### **8.1.2.1.1.3 练习 2: 父进程复制自己的内存空间给子进程（需要编码）**

创建子进程的函数 `do_fork` 在执行中将拷贝当前进程（即父进程）的用户内存地址空间中的合法内容到新进程中（子进程），完成内存资源的复制。具体是通过 `copy_range` 函数（位于 `kern/mm/pmm.c` 中）实现的，请补充 `copy_range` 的实现，确保能够正确执行。

请在实验报告中简要说明你的设计实现过程。
![image-20231210225820698](C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20231210225820698.png)

**proc.c/do_fork**

```cpp
    proc->pid = get_pid();
    hash_proc(proc);
    // list_add(&proc_list, &(proc->list_link));
    // nr_process++;
    set_links(proc);
```

**pmm.c/copy_range**

```cpp
             /*    memcpy: typical memory copy function
             *
             * (1) find src_kvaddr: the kernel virtual address of page
             * (2) find dst_kvaddr: the kernel virtual address of npage
             * (3) memory copy from src_kvaddr to dst_kvaddr, size is PGSIZE
             * (4) build the map of phy addr of  nage with the linear addr start
             */
            void *src_kvaddr = page2kva(page);
            void *dst_kvaddr = page2kva(npage);
            memcpy(dst_kvaddr, src_kvaddr, PGSIZE);
            ret = page_insert(to, npage, start, perm);

            assert(ret == 0);
```

- 如何设计实现 Copy on Write 机制？给出概要设计，鼓励给出详细设计。

Copy-on-write（简称 COW）的基本概念是指如果有多个使用者对一个资源 A（比如内存块）进行读操作，则每个使用者只需获得一个指向同一个资源 A 的指针，就可以该资源了。若某使用者需要对这个资源 A 进行写操作，系统会对该资源进行拷贝操作，从而使得该“写操作”使用者获得一个该资源 A 的“私有”拷贝—资源 B，可对资源 B 进行写操作。该“写操作”使用者对资源 B 的改变对于其他的使用者而言是不可见的，因为其他使用者看到的还是资源 A。

**答:**要实现 Copy on Write 机制，可以在复制父进程的内存空间给子进程时，**不复制整个内存页**，而是**只复制页表项**，然后将父进程和子进程的页表项的权限都设置为**只读**。这样两个进程都可以访问同一个内存页，当其中一个进程**要写入时**，会触发**缺页异常**，然后**在缺页异常处理函数中，复制整个内存页，设置可写入权限**，这时就可以写入了。当某个共享页面**只剩下一个进程时**，就可以将其**权限设置为可写**。
![image-20231210230447621](C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20231210230447621.png)

### **8.1.2.1.1.4 练习 3: 阅读分析源代码，理解进程执行 fork/exec/wait/exit 的实现，以及系统调用的实现（不需要编码）**

请在实验报告中简要说明你对 `fork/exec/wait/exit` 函数的分析。并回答如下问题：

- 请分析 `fork/exec/wait/exit` 的执行流程。重点关注哪些操作是在用户态完成，哪些是在内核态完成？内核态与用户态程序是如何交错执行的？内核态执行结果是如何返回给用户程序的？

### fork

用户态：
`fork()` -> `sys_fork()` -> `do_fork()` -> `syscall(SYS_fork)` -> `ecall` 

内核态：
`syscall()` -> `sys_fork()` -> `do_fork(0, stack, tf)`

`do_fork`中，调用 `alloc_proc` 分配一个 `proc_struct`，并设置父进程。调用 `setup_kstack` 为子进程分配一个内核栈，调用 `copy_mm` 根据 `clone_flag` 复制或共享 `mm`，调用 `copy_thread` 在 `proc_struct` 中设置 `tf` 和上下文，将 `proc_struct` 插入 `hash_list` 和 `proc_list`，调用 `wakeup_proc` 使新的子进程变为可运行状态，使用子进程的 pid 设置返回值.
![image-20231210172542563](C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20231210172542563.png)

### exec

内核态：
`kernel_execve()` -> `ebreak` -> `syscall()` -> `sys_exec()` -> `do_execve()`

检查用户提供的程序名称是否合法。
如果当前进程的 mm 不为空，说明当前进程占用了内存，进行相关清理操作，包括切换到内核页表、释放进程的内存映射、释放页目录表、销毁进程的内存管理结构等。
调用 `load_icode` 函数加载用户提供的二进制文件，将其代码段加载到内存中。
使用 `set_proc_name` 函数设置进程的名称。
![image-20231210165122966](C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20231210165122966.png)

### wait

用户态：
`wait()` -> `sys_wait()` -> `syscall(SYS_wait)` -> `ecall`

内核态：
`syscall()` -> `sys_wait()` -> `do_wait()`

首先进行内存检查，确保 `code_store` 指向的内存区域可访问。遍历查找具有给定PID的子进程，若找到且该子进程的父进程是当前进程，将 haskid 标志设置为1。如果 pid 为零，将循环遍历所有子进程，查找已经退出的子进程。如果找到，跳转到标签 found。如果存在子进程，将当前进程的状态设置为 `PROC_SLEEPING`，等待状态设置为 `WT_CHILD`，然后调用调度器 `schedule()` 来选择新的可运行进程。如果当前进程被标记为`PF_EXITING`，则调用 `do_exit` 以处理退出,跳转到标签 repeat 继续执行。
找到后检查子进程是否是空闲进程 `idleproc`或初始化进程 `initproc`，如果是则触发 panic。存储子进程的退出状态，处理子进程退出并释放资源。
![image-20231210145231608](C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20231210145231608.png)

### exit

用户态：
`exit()` -> `sys_exit()` -> `syscall(SYS_exit)` -> `ecall`

内核态：
`syscall()` -> `sys_exit()` -> `do_exit()`

检查当前进程是否是idleproc或initproc，若是则 `panic`。获取内存管理结构，减少对内存管理结构的引用计数，如果引用计数降为零，代表没有其他进程共享该内存管理结构，那么清理映射并释放页目录表，最后销毁内存管理结构。最后，将当前进程的 `mm` 指针设置为 `NULL`。将进程的状态设置为 `PROC_ZOMBIE`，表示进程已经退出。如果父进程正在等待子进程退出，则唤醒当前进程的父进程。然后，通过循环处理当前进程的所有子进程，将它们的状态设置为`PROC_ZOMBIE`，并将其重新连接到初始化进程的子进程链表上。如果初始化进程也正在等待子进程退出，那么也唤醒初始化进程。最后，进行调度。

![image-20231210130314640](C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20231210130314640.png)

- 请给出 ucore 中一个用户态进程的执行状态生命周期图（包括执行状态，执行状态之间的变换关系，以及产生变换的事件或函数调用）。（字符方式画即可）

![image-20231210231431076](C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20231210231431076.png)







执行：`make grade`。如果所显示的应用程序检测都输出 ok，则基本正确。（使用的是 qemu-1.0.1）


**说明该用户程序是何时被预先加载到内存中的？与我们常用操作系统的加载有何区别，原因是什么？**

在本次实验中，用户程序在**编译时被链接到内核中**，并定义好了起始位置和大小，然后在 `user_main()` 函数 `KERNEL_EXECVE` 宏调用 `kernel_execve()` 函数，从而调用 **`load_icode()` 函数将用户程序加载到内存中**。
而在我们常用的操作系统中，用户程序通常是存储在**外部存储设备上的独立文件**。当需要执行某个程序时，操作系统会从磁盘等存储介质上动态地加载这个程序到内存中。
原因是 ucore 没实现硬盘，出于简化和教学性质的考虑，将**用户程序编译到内核中**减少了实现的复杂度。



### **8.1.2.1.1.5 扩展练习 Challenge**

1. 实现 Copy on Write （COW）机制

   给出实现源码, 测试用例和设计报告（包括在 cow 情况下的各种状态转换（类似有限状态自动机）的说明）。

   这个扩展练习涉及到本实验和上一个实验“虚拟内存管理”。在 ucore 操作系统中，当一个用户父进程创建自己的子进程时，父进程会把其申请的用户空间设置为只读，子进程可共享父进程占用的用户内存空间中的页面（这就是一个共享的资源）。当其中任何一个进程修改此用户内存空间中的某页面时，ucore 会通过 page fault 异常获知该操作，并完成拷贝内存页面，使得两个进程都有各自的内存页面。这样一个进程所做的修改不会被另外一个进程可见了。请在 ucore 中实现这样的 COW 机制。

   由于 COW 实现比较复杂，容易引入 bug，请参考 https://dirtycow.ninja/ 看看能否在 ucore 的 COW 实现中模拟这个错误和解决方案。需要有解释。

   这是一个 big challenge.

2. 说明该用户程序是何时被预先加载到内存中的？与我们常用操作系统的加载有何区别，原因是什么？