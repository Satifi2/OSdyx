### 实验准备

在lab1可以运行的前提下，确保makefile里面的qemu可以工作，如果makefile被修改错了，粘贴原始lab2里面的makefile进行覆盖。

中间可能提示fatal error: -fuse-linker-plugin, but liblto_plugin.so not found，需要在工具链目录下找到 liblto_plugin.so.0.0.0 复制成一份 liblto_plugin.so 顺利解决

开始实验：修改makefile里面的opensbi的版本为正确版本,修改bios对应文件为GitHub下载下来的文件:
<img src="C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20231013183323996.png" alt="image-20231013183323996" style="zoom:50%;" />

此时可以make qemu应该可以看到大量的kkkk
<img src="C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20231013183845696.png" alt="image-20231013183845696" style="zoom:50%;" />
为什么出现kkk呢，因为debug的panic.c里面故意设置了一个for循环输出k，把它注释掉就行

<img src="C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20231013184347083.png" alt="image-20231013184347083" style="zoom: 33%;" />

此时再make qemu,可以看到opensbi被启动了：
<img src="C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20231013184824216.png" alt="image-20231013184824216" style="zoom:50%;" />

然后了解一下库函数list后面有用
![image-20231013213100715](C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20231013213100715.png)

list是一个双向链表，可以被struct list_entry理解为node,又把struct list_entry简写为list_entry_t

其中这里的add很迷，__list_add是把elm插入节点prev和next之间。list_add_after是把elm插入listelm和listelm->next之间，和list_add一模一样。而list_add_before是把elm插入listelm和listelm->pre之间。init是让前后指针指向自己。

__list_del是让pre和next指向彼此，list_del是删掉一个元素，list_del_init是删掉元素，让它自己指向自己，list_empty通过是否指向自己判断是不是空的，list_prev和list_next是获取list前后元素的接口。
为了测试list，这里写了一个testlist放在test文件夹里面
<img src="C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20231013214915889.png" alt="image-20231013214915889" style="zoom:50%;" />

可以实现基本的插入删除

<img src="C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20231013214948482.png" alt="image-20231013214948482" style="zoom:50%;" />





#### 练习1：理解first-fit 连续物理内存分配算法（思考题）

first-fit 连续物理内存分配算法作为物理内存分配一个很基础的方法，需要同学们理解它的实现过程。请大家仔细阅读实验手册的教程并结合`kern/mm/default_pmm.c`中的相关代码，认真分析default_init，default_init_memmap，default_alloc_pages， default_free_pages等相关函数，并描述程序在进行物理内存分配的过程以及各个函数的作用。
请在实验报告中简要说明你的设计实现过程。请回答如下问题：

- 你的first fit算法是否有进一步的改进空间？
  

#### 练习2：实现 Best-Fit 连续物理内存分配算法（需要编程）

在完成练习一后，参考kern/mm/default_pmm.c对First Fit算法的实现，编程实现Best Fit页面分配算法，算法的时空复杂度不做要求，能通过测试即可。
请在实验报告中简要说明你的设计实现过程，阐述代码是如何对物理内存进行分配和释放，并回答如下问题：

- 你的 Best-Fit 算法是否有进一步的改进空间？

#### 扩展练习Challenge：buddy system（伙伴系统）分配算法（需要编程）

Buddy System算法把系统中的可用存储空间划分为存储块(Block)来进行管理, 每个存储块的大小必须是2的n次幂(Pow(2, n)), 即1, 2, 4, 8, 16, 32, 64, 128...

 -  参考[伙伴分配器的一个极简实现](http://coolshell.cn/articles/10427.html)， 在ucore中实现buddy system分配算法，要求有比较充分的测试用例说明实现的正确性，需要有设计文档。

#### 扩展练习Challenge：任意大小的内存单元slub分配算法（需要编程）

slub算法，实现两层架构的高效内存单元分配，第一层是基于页大小的内存分配，第二层是在第一层基础上实现基于任意大小的内存分配。可简化实现，能够体现其主体思想即可。

 - 参考[linux的slub分配算法/](http://www.ibm.com/developerworks/cn/linux/l-cn-slub/)，在ucore中实现slub分配算法。要求有比较充分的测试用例说明实现的正确性，需要有设计文档。

#### 扩展练习Challenge：硬件的可用物理内存范围的获取方法（思考题）

  - 如果 OS 无法提前知道当前硬件的可用物理内存范围，请问你有何办法让 OS 获取可用物理内存范围？


> Challenges是选做，完成Challenge的同学可单独提交Challenge。完成得好的同学可获得最终考试成绩的加分。